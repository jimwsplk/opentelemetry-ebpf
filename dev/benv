#!/bin/bash
# Copyright The OpenTelemetry Authors
# SPDX-License-Identifier: Apache-2.0

## Alias to build the build-env container, which in turn is used for
# building all of the code in the "flowmill" monorepo.  Source this
# file in your ~/.bash_profile to set up the `benv` alias.

# To use a ramdisk for the build output set environment variable
# `EBPF_NET_BENV_RAMDISK` to either `ramfs` or `tmpfs` depending on the type of
# ramdisk to use. To use RAM exclusively with no size limit, use `ramfs`. To
# limit the size of the ramdisk but potentially use swap space, use `tmpfs`.
# The size limit defaults to `8g`, but can be specified using environment
# variable `EBPF_NET_BENV_RAMDISK_SIZE`.

# Add arguments to docker by creating a file under `$HOME/.flowmill/build-env/docker.d/` which
# updates the list of arguments in the bash array `docker_args`.
#
# You can find a useful list of hard-linkable config files under `$EBPF_NET_SRC/build-env/benv/docker.d/`.
#
# Sample $HOME/.flowmill/build-env/docker.d/vim:
# ```
#   docker_args+=(
#     --mount "type=bind,source=$HOME/.vim,destination=${guest_home}/.vim,readonly"
#     --mount "type=bind,source=$HOME/.vimrc,destination=${guest_home}/.vimrc,readonly"
#   )
# ```

set -x
export EBPF_NET_SRC_ROOT="${EBPF_NET_SRC_ROOT:-$(git rev-parse --show-toplevel)}"

source "${EBPF_NET_SRC_ROOT}/dev/script/benv-error-lib.sh"
source "${EBPF_NET_SRC_ROOT}/dev/script/benv-lib.sh"

# use image built by gitlab to artifactory by default. There is a list of tags at:

# https://repo.splunkdev.net/ui/packages/docker:%2F%2Fo11y-npm%2Fbld%2Fbenv-final?name=o11y-npm&type=packages
EBPF_NET_BENV_IMAGE="quay.io/splunko11ytest/network-explorer-debug/build-env:latest"
pull_image='true'

# home directory within the guest
guest_home="/root"
guest_out_dir="${guest_home}/out"
guest_go_path="${guest_out_dir}/go-path"
container_name="$(get_benv_container_name)"
container_entrypoint='/bin/bash'

function print_help {
  echo "usage: $0 [options...] [-- docker_extra_args... [-- guest_bash_args...]]"
  echo
  echo "  -a | --attach: opens an interactive shell to an existing `benv` container"
  echo "  -l | --local-image: use locally built build environment image"
  echo "  -s | --skip-image-pull: skips pulling benv image from ECR"
  echo "       --docker: skips mounting the host's docker socket"
  echo "  -h | --help: print this help message"
}

unset docker_extra_args
declare -a docker_extra_args

attach_to_existing_benv=false
mount_docker_socket=true

# process benv args
while [[ "$#" -gt 0 ]]; do
  arg="$1"; shift
  case "${arg}" in
    -a | --attach)
      attach_to_existing_benv=true
      ;;

    # option to run benv in a way that supports eBPF to allow kernel-collector testing (priviliged, required mounts)
    -e | --ebpf-support)
      ebpf_support=true
      ;;

    -l | --local-image)
      if [[ -z "${EBPF_NET_BENV_VERSION}" ]]; then
        EBPF_NET_BENV_VERSION="latest"
      fi
      EBPF_NET_BENV_IMAGE="${DOCKER_TAG_PREFIX}build-env:${EBPF_NET_BENV_VERSION}"
      pull_image='false'
      ;;

    -s | --skip-image-pull)
      pull_image='false'
      ;;

    --docker)
      mount_docker_socket=false
      ;;

    --)
      break
      ;;

    -h | --help)
      print_help
      exit 0
      ;;

    *)
      echo "ERROR: invalid argument '${arg}'"
      exit 1
      ;;
  esac
done

# process docker extra args
while [[ "$#" -gt 0 ]]; do
  arg="$1"; shift
  case "${arg}" in
    --)
      break
      ;;

    *)
      docker_extra_args+=("${arg}")
      ;;
  esac
done

container_args=("$@")
docker_args=(-it --rm)

if [ "${attach_to_existing_benv}" == true ]; then
  exec docker exec -it "${container_name}" \
    "${container_entrypoint}" -- "${container_args[@]}"
fi

KNOWN_HOST_BUILD_DIR='/tmp/flowmill-benv-out'

BENV_CACHE_CCACHE="$HOME/.ccache"; [ -d "${BENV_CACHE_CCACHE}" ] || mkdir -p "${BENV_CACHE_CCACHE}"
BENV_CACHE_GO_DIRS=(mod sumdb)
BENV_CACHE_GO="$HOME/.go.benv";
for dir in "${BENV_CACHE_GO_DIRS[@]}"; do
  [ -d "${BENV_CACHE_GO}/pkg/${dir}" ] || mkdir -p "${BENV_CACHE_GO}/pkg/${dir}"
  docker_args+=( \
    --mount "type=bind,source=${BENV_CACHE_GO}/pkg/${dir},destination=${guest_go_path}/pkg/${dir},consistency=delegated"
  )
done

# build output directory management
host_build_dir="${KNOWN_HOST_BUILD_DIR}"
ramdisk_host_build_dir="${KNOWN_HOST_BUILD_DIR}-ramdisk"
if mount | grep "${ramdisk_host_build_dir} > /dev/null 2>&1"; then
  (set -x; sudo umount "${ramdisk_host_build_dir}")
fi
if [[ -z "${EBPF_NET_BENV_RAMDISK}" ]]; then
  # regular directory
  host_build_dir="`mktemp -d /tmp/flowmill-benv-out-XXXX`"
else
  # ramdisk
  if [[ -z "${EBPF_NET_BENV_RAMDISK_SIZE}" ]]; then
    EBPF_NET_BENV_RAMDISK_SIZE="8g"
  fi
  mkdir -p "${ramdisk_host_build_dir}"
  (set -x; sudo mount -t "${EBPF_NET_BENV_RAMDISK}" \
    -o size="${EBPF_NET_BENV_RAMDISK_SIZE}" \
    "${EBPF_NET_BENV_RAMDISK}" \
    "${ramdisk_host_build_dir}" \
  )
  host_build_dir="${ramdisk_host_build_dir}"
fi
[[ ! -e "${KNOWN_HOST_BUILD_DIR}" ]] || rm -rf "${KNOWN_HOST_BUILD_DIR}"
ln -s "${host_build_dir}" "${KNOWN_HOST_BUILD_DIR}"

docker_args+=( \
  --privileged
  --network="host"

  --mount "type=bind,source=$host_build_dir,destination=${guest_out_dir}"
  --mount "type=bind,source=${BENV_CACHE_CCACHE},destination=${guest_home}/.ccache,consistency=delegated"

  #--mount "type=bind,source=$HOME/.aws,destination=${guest_home}/.aws"
  #--env AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
  #--env AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
  #--env AWS_SECURITY_TOKEN="${AWS_SECURITY_TOKEN}"
  #--env AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN}"
  #--env AWS_VAULT="${AWS_VAULT}"

  --env EBPF_NET_INTAKE_HOST="127.0.0.1"
  --env EBPF_NET_INTAKE_PORT="8000"

  --env EBPF_NET_TOOLS_DIR="${guest_out_dir}/tools"
  --env EBPF_NET_OUT_DIR="${guest_out_dir}"

  --env GIT_USER="$(git config user.name)"
  --env GIT_EMAIL="$(git config user.email)"

  --mount "type=bind,source=$EBPF_NET_SRC_ROOT,destination=${guest_home}/src,readonly"
  --env EBPF_NET_SRC="${guest_home}/src"
  --env EBPF_NET_SRC_ROOT="${guest_home}/src/opentelemetry-ebpf"

  --workdir "${guest_out_dir}"

  --name "${container_name}"
)
if [ "${ebpf_support}" == true ]; then
  docker_args+=( \
    --privileged
    --mount "type=bind,source=/lib/modules,destination=/lib/modules,readonly"
    --mount "type=bind,source=/usr/src,destination=/usr/src,readonly"
    --mount "type=bind,source=/sys/kernel,destination=/sys/kernel,readonly"
    --mount "type=bind,source=/sys/fs/cgroup,destination=/hostfs/sys/fs/cgroup"
  )
fi

if [ -d "/usr/local/bin" ]; then
  docker_args+=( \
    --mount "type=bind,source=/usr/local/bin,destination=${guest_home}/usr/local/bin,readonly"
  )
fi

if [[ "${mount_docker_socket}" == "true" ]]; then
  docker_args+=( \
    --mount "type=bind,source=/var/run/docker.sock,destination=/var/run/docker.sock"
  )
fi

if [[ "${EBPF_NET_BENV_MOUNT_KERNEL_HEADERS}" == "true" ]]; then
  docker_args+=( \
    --volume /usr/src:/usr/src
    --volume /lib/modules:/lib/modules
  )
fi

if [ -d "$HOME/.flowmill/build-env/docker.d/" ]; then
  for f in `find "$HOME/.flowmill/build-env/docker.d/" -type f`; do
    if [ -e "$f" ]; then
      . "$f"
    fi
  done
fi

if [[ "${pull_image}" == 'true' ]]; then
  #JMW "${EBPF_NET_SRC}/dev/docker-registry-login.sh" okta
  docker pull "${EBPF_NET_BENV_IMAGE}"
fi

exec docker run "${docker_args[@]}" "${docker_extra_args[@]}" "${EBPF_NET_BENV_IMAGE}" \
  "${container_entrypoint}" "${container_args[@]}"
